# Java Basics

## 1. JRE vs JDK

### JDK (Java Development Kit)
JDK — набор программ для разработки. Включает:
- **JRE** (Java Runtime Environment)
- Компилятор `javac`
- Загрузчик кода Java
- Архиватор `jar`
- Генератор документации `javadoc`
- Другие утилиты, нужные во время разработки.

### JRE (Java Runtime Environment)
JRE — это набор инструментов для запуска Java-программ. Включает:
- Виртуальную машину Java (JVM)
- Библиотеки стандартных пакетов, таких как:
    - `java.lang`, `java.util` (базовые пакеты)
    - Пакеты для работы с базами данных, пользовательским интерфейсом и другими форматами данных.

JRE отвечает за объединение Java-кода с необходимыми библиотеками и запуск JVM для выполнения программы.

### JVM (Java Virtual Machine)
JVM — основная часть JRE. Она исполняет байт-код Java, который компилятор (`javac`) создаёт из исходного кода Java.

#### Основные части JVM:
1. **Runtime** — отвечает за выполнение байт-кода.
2. **Garbage Collector (GC)** — управляет памятью.
3. **JIT-компилятор** — оптимизирует выполнение байт-кода.

### JIT (Just-In-Time Compiler)
JIT — компонент JVM, который улучшает производительность Java-программ за счёт компиляции байт-кода в машинный код на этапе выполнения.

#### Как работает JIT:
1. **Байт-код**: Компиляция Java-кода в .class-файлы.
2. **Интерпретация**: JVM сначала интерпретирует байт-код (выполняет построчно).
3. **JIT-компиляция**: Преобразует часто используемые части байт-кода (циклы, методы) в машинный код, что ускоряет выполнение.
4. **Кэширование**: Скомпилированный код сохраняется для повторного использования.

---

## 2. Для чего нужен байт-код?

### Основные преимущества байт-кода:
1. **Портативность**:
    - Байт-код независим от архитектуры и операционной системы.
    - Java-программы можно запускать на любом устройстве с установленной JVM (Windows, Linux, macOS, Android).
    - Это соответствует принципу Java: **"Write Once, Run Anywhere"**.

2. **Оптимизация исполнения**:
    - Байт-код представляет собой компактные числовые инструкции и ссылки на память.
    - Передаётся в JVM для интерпретации и выполнения.

---

## 3. Double и Float

### Стандарты представления чисел (IEEE-754):

| Характеристика      | **float**             | **double**            |
|---------------------|-----------------------|-----------------------|
| **Биты на дробную часть** | 23                    | 52                    |
| **Биты на степень**       | 8                     | 11                    |
| **Бит на знак**           | 1                     | 1                     |
| **Точность**              | ~7 знаков             | ~16 знаков            |

#### Пример диапазона точности:
- **float**: от 6 до 9 цифр (в среднем 7).
- **double**: от 15 до 18 цифр (в среднем 16).

---

## 4. Когда необходимы явные, а когда неявные преобразования типов?

### Пример кода:
```java
long l = 23453456L;
float f = l;
```

### Как это работает:
1. **`long l = 23453456L;`**
    - Переменной `l` присваивается значение типа `long`.
    - Суффикс `L` указывает компилятору, что это литерал типа `long`.

2. **`float f = l;`**
    - Происходит **неявное преобразование** (`widening conversion`) от типа `long` к `float`.
    - Такое преобразование разрешено, так как диапазон значений `long` входит в диапазон `float`.

#### Ограничение:
- **float** имеет меньшую точность (~7 значащих цифр), чем `long`. Поэтому возможно округление или потеря младших разрядов.

### Итог:
- Явные преобразования требуются, когда есть риск потери данных (например, `float` → `int`).
- Неявные преобразования возможны при расширении типа (например, `int` → `float`).
