1. нахрена нужно наследование? какой от него толк и профит?
    1. Повторное использование кода (reusability) (код повторно использован в наследниках)
    2. Расширение функциональности (extensibility) (добавление функционала в дочерних классах)
    3. Обеспечение единого интерфейса (по сути тот же пункт что и 4)
    4. Полиморфизм (Наследование позволяет использовать полиморфизм, то есть работать с объектами разных классов как с объектами одного типа.)
    5. Централизованное управление общими изменениями (тип поменять сам родительский класс)


2. отрефакторить робота
сделано


3. методы в enum
enum добавились в java 5

enum - класс унаследованный от Enum

по сути представляет собой класс, для которого объекты класса уже созданы,
может иметь поля и методы, а также конструкторы, но только private и package-private


4. контракт equals и hashcode

1) Если x.equals(y) == true, то обязательно hashcode(x) == hashcode(y)
2) Если hashcode(x) == hashcode(y), то не обязательно x.equals(y) == true

Требования к переопределенному equals:
    1. Рефлективность. Для любого заданного значения x, выражение x.equals(x) должно возвращать true
    2. Симметричность. Для любых заданных значений x и y, x.equals(y) должно возвращать true только в том случае,
    когда y.equals(x) возвращает true
    3. Транзитивность. Для любых заданных значений x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true,
    x.equals(z) должно вернуть значение true.
    4. Согласованность. Для любых заданных значений x и y повторный вызов x.equals(y) будет возвращать значение
    предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.
    5. Сравнение null. Для любого заданного значения x вызов x.equals(null) должен возвращать false.

Хэш — это некоторое число, генерируемое на основе объекта и описывающее его состояние в какой-то момент времени.
Это число используется в Java преимущественно в хэш-таблицах, таких как HashMap. При этом хэш-функция получения
числа на основе объекта должна быть реализована таким образом, чтобы обеспечить относительно равномерное распределение
элементов по хэш-таблице. А также минимизировать вероятность появления коллизий, когда по разным ключам функция
вернет одинаковое значение.

При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.

Требования к переопределенному hashcode:
    1. вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение,
    при условии что поля объекта, участвующие в вычислении значения, не изменялись.
    2. вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны
    (вызов метода equals для этих объектов возвращает true).
    3. вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это
    требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на
    производительность работы хэш-таблиц.

Методы equals и hashCode необходимо переопределять вместе
Исходя из описанных выше контрактов следует, что переопределяя в своем коде метод equals, необходимо всегда
переопределять и метод hashCode. Так как фактически два экземпляра класса отличаются, потому что находятся в
разных областях памяти, сравнивать их приходится по некоторым логическим признакам. Соответственно, два логически
эквивалентных объекта, должны возвращать одинаковое значение хэш-функции.

Таким образом, мы видим, что методы equals и hashCode играют четко определенную роль в языке Java и предназначены
для получения характеристики логического равенства двух объектов. В случае с методом equals это имеет прямое отношение
к сравнению объектов, в случае с hashCode косвенное, когда необходимо, скажем так, определить примерное расположение
объекта в хэш-таблицах или подобных структурах данных с целью увеличения скорости поиска объекта.

5. разница между лямбдами и анонимными классами?
лямбда - метод записанный в переменную, является реализацией функционального интерфейса (подвезли в java 8)
главное преимущество - значительное сокращение кода
полезно, если интерфейс нужно реализовать 1 раз
лямбды лаконичнее и требуют меньше кода чем анонимные классы

лямбда-выражения могут заменить анонимные классы, которые реализуют функциональные интерфейсы,
но в остальных случаях анонимные классы не теряют актуальности.

прикол анонимных классов же в том, что что это класс, но способен переопределить более одного метода,
у него могут быть поля

// просить у толи за статические методы в анонимных классах

6. порешать проблему с магическими числами, убрать постоянное вычисление степени
Магические числа — это числа в коде, смысл которых сложно понять сходу.

порешено файл Rectangle


7.  к 3.5.2
В классе ASCICharSquence написать метод subSequence(int start), который будет возвращать подполедовательность
(экземпляр ASCICharSquence) от заданного символа до конца строки

и еще метод delete(int from, int to), который возвращает последовательность (экземпляр ASCICharSquence)
символов с удаленными символами от from до to, при этом "сжимая" строку, объект на котором был вызван метод меняться не должен
пример на псевдокоде!
Ялюблюсобак.delete(1,4) == Ясобак

решено для английских букв
второе 2 способами


8. доп к заданию 3.5.3
Написать текстовый анализатор, который бы конструировался от массива ключевых слов и максимального количества
употребления одного ключевого слова возвращает метку TOO_MUCH_KEYWORDS в случае, если хотя-бы одно из слов
встречается больше чем заданное максимальное число

Ключевые слова: джава
Макс количество: 3

Текст: я джава, я учу людей джава, джава чертовски хорош, джава это куча денег, джава
Ответ анализатор TOO_MUCH_KEYWORDS

Текст: джава это круто
Ответ: OK

задача решена, класс TooMuchKeyWordsAnalyzer в папке text_analozier

9. в каких случаях использовать абстрактный класс а в каких интерфейс?

абстрактный класс, когда есть общие поля, которые можно объявить в абстрактном классе
интерфейс когда только функционал

полностью абстрактный класс может иметь состояние, а интерфейс - нет.
Отсюда вытекает использование:
    если у наследников должно быть общее описание состояния - использовать абстрактный класс,
    во всех других случаях - интерфейс.

3 класса описывающие схожие сущности, имеют метод\ы с одинаковой реализацией,
тогда выносим этот метод в абстрактный класс. если есть поля с которыми метод взаимодействует, то их тоже в абстрактный класс

поля в интерфесах только public static final инициализированы (то есть константы по сути)

10. нахуя return null в абстрактном классе?
тупанул, автоматическая имплементация, пофикшено, теперь буду смотреть че за код генерится
идея с выносом keywords в абстрактный класс


11. как работает final?

final в java могут быть разные вещи:
    классы
    поля
    методы
    переменные
    аргументы

    пример всего в классе FinalExample


12. как передаются параметры в методе?

public class Example {
    public static void main(String[] args) {
        final int[] mas = {0, 0, 0};
        anotherMethod(mas);
        System.out.println(Arrays.toString(mas));
    }
    public static void method(int[] arr) {
        arr[0] = 999;
    }
  public static void anotherMethod(int[] arr) {
        int[] mas = {1,1,1};
        arr = mas;

    }
}

В java все параметры передаются по значению,
только для примитивов создается копия переданного аргумента,
а для объектов и массивов передается копия ссылки (можно изменять начальное значение, но саму ссылку изменить нельзя)

поэтому, в случае method(int[] arr) число изменится,
         в случае anotherMethod(int[] arr) массив не изменится, т.к. изменится значение ссылки, а не содержимое

         при этом, даже если объявить mas final, это ничего не изменит, содержимое также можно будет изменить,
         но сам объект заменить не получится

         при этом в самом методе main нельзя изменить ссылку на объект (присвоить переменной ссылку на другой объект,
         изменять же содердимое можно.



